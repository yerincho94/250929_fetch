<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fetch</title>
    <!-- 인터넷에서 데이터를 읽어드릴때의 사용방법 -->
  </head>
  <body>
    <input type="text" id="userId" placeholder="유저 아이디를 입력하세요" />
    <button id="userIdBtn">조회</button>
    <!-- https://jsonplaceholder.typicode.com/ -->
    <script>
      // XMLHttpRequest <- 예전 방식
      // fetch (axious, ky ...) 이걸로 많이 대체 되었다.
      // Promise -> 원래 흐름과 별도로 외부 네트워크의 종료 여부를 알아서 처리하게
      const response = fetch("https://jsonplaceholder.typicode.com/users/1");
      console.log(response); //Promise
      //promise는 then으로
      response
        .then((res) => {
          console.log(res.status); //200 : 정상적으로 값 받았음
          console.log(res.ok); // 2xx status -> true , 나머지 4xx, 5xx -> false
          //res.text().then(console.log); //json string 형태 //둘이 같이 못씀
          //res.json().then(console.log); //Json String -> js 객체로 변환
          return res.json();
        })
        .then((data) => console.log(data)); //원한다면 promise 값을 다음으로 return해서 새로운 체이닝의 then으로 받을 수 있음.

      async function fetchUser() {
        const userId = document.querySelector("#userId").value; //1~10

        const response = await fetch(
          //"https://jsonplaceholder.typicode.com/users/1"
          `https://jsonplaceholder.typicode.com/users/${userId}`
        );
        const data = await response.json();
        console.log("data: ", data);
        //1. Promise -> then => async await 사용 (1번 써준다고 끝나는게 아니라 결과값이 Promise먄 그때마다....)
        //2. await -> async로 감싸줘야한다.
      }
      //fetchUser(); //어떨 때 호출이 되는가? -> Event와 관련이 있다.(button, form, dom 로딩될때 --> 네트워크 요청)
      //Listener -> Callback (handler 함수) --> async + await

      //함수를 넣어줘야함
      document.querySelector("#userIdBtn").addEventListener("click", fetchUser);
    </script>
  </body>
</html>
